---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jjq.
--- DateTime: 2019/11/26 15:28
---

local skynet    				= require "skynet"
local socketdriver 				= require "skynet.socketdriver"
local socket 					= require "skynet.socket"
local service 					= require "skynet.service"
local websocket 				= require "http.websocket"

local default_max_client 	= 1024

local id					--当前监听的socket fd
local watchdog 				--地址
local nodelay  				= true--nodelay
local fd_2_conn	 			= {} 	--{[fd] -> {fd,agent,ip}}
local agent_2_conn  		= {}	--{[agent] -> {fd,agent,ip}}
local maxclient				= default_max_client--最大连接数
local client_number			= 0--当前连接数

--接口函数
local wshandle = {}
local CMD = {}

skynet.register_protocol {
	name = "client",
	id = skynet.PTYPE_CLIENT,
}

local function unforward(c)
	if c.agent then
		agent_2_conn[c.agent] 	= nil
		c.agent 				= nil
	end
end


local function close_fd(fd)
	local c = fd_2_conn[fd]
	if c then
		unforward(c)
		fd_2_conn[fd] = nil
		websocket.close(fd)
		client_number = client_number and (client_number - 1)
	end
end


function wshandle.connect(fd)

end

function wshandle.handshake(fd, header, url)

	if client_number >= maxclient then
		websocket.close(fd)
		return
	end

	if nodelay then
		socketdriver.nodelay(fd)
	end

	client_number = (client_number or 0) + 1

	local addr = websocket.addrinfo(fd)

	local ip,port = string.match(addr,"([^:]+):(%d+)")

	local c = {
		fd = fd,
		ip = ip,
	}

	fd_2_conn[fd] = c

	skynet.send(watchdog, "lua", "socket", "open", fd, ip,port)

end

function wshandle.message(fd, msg)
	local c = fd_2_conn[fd]

	if not c then
		return
	end

	local agent = c.agent

	if agent then
		skynet.redirect(agent,0, "client", fd, msg)
	else
		skynet.send(watchdog,"lua", "socket", "data", fd, msg)
	end
end

function wshandle.ping(fd)
end

function wshandle.pong(fd)
end

function wshandle.close(fd, code, reason)
	close_fd(fd)
	skynet.send(watchdog, "lua", "socket", "close", fd)
end

function wshandle.error(fd)
	close_fd(fd)
	skynet.send(watchdog, "lua", "socket", "error", fd, "error")
end



--watchdog开启监听
function CMD.listen(source,conf)
	assert(not id)

	fd_2_conn 		= {}
	agent_2_conn 	= {}
	client_number 	= 0

	watchdog = source

	local address = conf.address or "0.0.0.0"
	local port = assert(conf.port)
	maxclient = conf.maxclient or default_max_client
	nodelay = conf.nodelay

	print_color(32,string.format("Listen on %s:%d", address, port))

	id = socket.listen(address, port)

	socket.start(id, function(fd,addr)
		websocket.accept(fd,wshandle,"ws",addr)
	end)
end

--关闭掉整个id的监听
function CMD.close()
	if not id then
		return false
	end

	if fd_2_conn and next(fd_2_conn) then
		for fd,c in pairs(fd_2_conn) do
			websocket.close(fd)
		end
	end


	fd_2_conn = {}
	agent_2_conn = {}

	client_number = 0

	socket.close(id)

	skynet.error("close listen success!")

	id = nil

	return true
end

--agent给的回调
function CMD.forward(source,fd,client,addr)
	if watchdog == source then
		return false
	end

	local c = fd_2_conn[fd]

	if not c then
		return false
	end

	unforward(c)

	c.agent = source

	agent_2_conn[source] = c

	return true
end

--watchdog给的回调
function CMD.accept(source,fd)

	if source ~= watchdog then
		return false
	end

	local c = fd_2_conn[fd]

	if not c then
		return false
	end

	unforward(c)

	return true
end

--踢下线
function CMD.kick(source,fd)
	close_fd(fd)
end

--[[local function ping_timer()
	while true do
		skynet.sleep(1 * 100)

		if not fd_2_conn or not next(fd_2_conn) then
			goto continue
		end

		for fd,c in pairs(fd_2_conn) do
			websocket.ping(fd)
		end

		::continue::
	end
end]]

skynet.start(function()
	skynet.dispatch("lua", function (session, source, cmd, ...)
		local f = CMD[cmd]
		if f then
			skynet.ret(skynet.pack(f(source, ...)))
		end
	end)

	--skynet.fork(ping_timer)
end)